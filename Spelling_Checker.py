import sys, string, re 
import time as time_ 

dictionary = open("/usr/share/dict/words", 'r')
knownWords = {word.strip().lower() for word in dictionary}
dictionary.close()
vowels = 'aeiou'


def ms():
    return int(round(time_.time()*1000))

def timer(startTime):
    x = int(round(time_.time()*1000)) - startTime
    if x > 15000:
        return True
    return False

def find_jaccard_coefficient(bgs, kw, candidatesDict):
    """
    Returns the Jaccard Similarity Coefficient between the bi-gram sets 
    of the input word and each candidate word

    Reference: http://en.wikipedia.org/wiki/Jaccard_index
    
    """
    union = bgs.union(candidatesDict[kw])
    intersect = bgs.intersection(candidatesDict[kw])
    return len(intersect)/len(union)

# def replace_helper(word, pos, letter):
#     """
#     helper method for replace_vowel

#     """
#     newWord = ''
#     for i in range(0, len(word)):
#         if i == pos:
#             newWord += letter
#         else:
#             newWord += word[i]
#     return newWord

def replace_vowel(word, pos, someSet, startTime, testing): 
    """
    Returns a set of strings where the strings are generated by replacing 
    and adding more vowels from what the word originally had. Note that the
    result only contains words in knownWords.

    >>> replace_vowel('shep', 0, set())
    {'ship', 'shop', 'shap'}

    """
    temp = set()
    if testing:
        return replace_vowel_helper2(word, pos, someSet, startTime, temp)
    return replace_vowel_helper1(word, pos, someSet, startTime, temp)

def replace_vowel_helper1(word, pos, someSet, startTime, temp): 
    if timer(startTime): # Max out being time spent for this function
        return someSet

    for index in range(pos, len(word)):
        if word[index] in vowels:
            for v in vowels:
                # newWord = replace_helper(word, index, v)
                newWord = word[:index] + v + word[index+1:]
                if newWord not in temp:
                    temp.add(newWord)
                    replace_vowel_helper1(newWord, index+1, someSet, startTime, temp)
                    if newWord in knownWords:
                        someSet.add(newWord)

    return someSet       


def replace_vowel_helper2(word, pos, someSet, startTime, temp): 
    for index in range(pos, len(word)):
        if word[index] in vowels:
            for v in vowels:
                # newWord = replace_helper(word, index, v)
                newWord = word[:index] + v + word[index+1:]
                if newWord not in temp:
                    temp.add(newWord)
                    replace_vowel_helper2(newWord, index+1, someSet, startTime, temp)
                    if newWord in knownWords:
                        someSet.add(newWord)

    return someSet      


def repeat_char(word, someSet):
    """
    Returns a set of strings where the strings are permutations with  
    less repeated letters. They are generated from the word that has 
    consecutive repeated letters.

    >>> repeat_char('sheepp', set())
    {'sheep', 'shep', 'shepp'}

    """
    temp = ''
    consecutive = 1
    index = 0
    for letter in word:
        if consecutive >= 3:
            break
        if temp == letter:
            newWord = word[:index-1]+word[index:]
            repeat_char(newWord, someSet)
            someSet.add(newWord)
            consecutive += 1
        else:
            consecutive = 1
        temp = letter
        index += 1

    return someSet


def spelling_check(word, testing):
    if word == '':
        return

    # Use Regex to get rid of too many repeated characters
    word = re.sub(r"(\w)\1{2,}", r"\1\1\1", word) # Any char more than 3 consecutively
    word = re.sub(r"[aeiou]{7,}", "eeeeee", word) # Vowels more than 6 consecutively 

    # Generate a set of permutations of words with less repeated letters.
    repeatCharSet = {word} 
    repeat_char(word, repeatCharSet)
    # print(word+" has repeatCharSet: ", repeatCharSet) # Debuggin purpose

    # Based on the previous set, we generate a new set of words by replacing/adding 
    # more vowels from what the words originally had.
    startTimeForReplaceVowel = ms()
    candidatesSet = set()
    for word in repeatCharSet:
        replace_vowel(word, 0, candidatesSet, startTimeForReplaceVowel, testing)
    # print(word+" has candidatesSet: ", candidatesSet) # Debuggin purpose

    # Transform each candidate that exists in the dictionary into its constituent bi-grams.
    candidatesDict = dict()
    for candidate in candidatesSet:
        candidatesDict[candidate] = {candidate[i:i+2] for i in range(0,len(candidate))}

    # Do the same for the misspelling.
    bigramSet = {word[i:i+2] for i in range(0, len(word))}

    # Calculate the Jaccard Similarity Coefficient of the bi-gram set of the misspelling 
    # to the bi-gram sets of the candidates in the dictionary.
    candidates = dict()
    maxJaccardCoef = 0
    for candidate in candidatesDict.keys():
        # If only an answer is left, there is no point for doing any calculation.
        if len(candidatesDict) == 1: 
            candidates[candidate] = 1.0
            break

        # Collect those candidates with a Jaccard score higher than some threshold.
        jCoef = find_jaccard_coefficient(bigramSet, candidate, candidatesDict)
        if jCoef >= 0.01:
            candidates[candidate] = jCoef
            if maxJaccardCoef < jCoef:
                maxJaccardCoef = jCoef


    if len(candidates) == 0:
        # print(word+' has no suggestion.') # Debuggin purpose

        return 'NO SUGGESTION'
    else:
        # Sort the last remaining candidates in a rare case where their Jaccard Coefs are equal.
        # For example: weke => {'wake': 0.33, 'woke': 0.33, 'weka': 0.33, 'weki': 0.33}
        ls = [word for word in candidates.keys() if candidates[word] >= maxJaccardCoef]
        ls = sorted(ls)
        # print(candidates) # Debuggin purpose
        return ls[0]


def main():
    while(True):
        word = input("> ").strip().lower()
        testing = False
        if 'exit()' in word: # type exit() to quit
            print('Quit program. Bye!')
            break

        elif 'test()' in word: # type test() to test with file words.txt
            testing = True
            print('Testing...')
            result = 'Test passed'
            test_cases = open("Generated_Words.txt", 'r')
            startTime = ms()
            answers = dict()
            for test in test_cases:
                suggestedWord = spelling_check(test.strip().lower(), testing)
                if suggestedWord not in answers:
                    answers[suggestedWord] = 1
                else:
                    answers[suggestedWord] += 1
                if 'NO SUGGESTION' == suggestedWord:
                    result = 'Test failed'
                    break
            print(result)
            print('Words are: ', answers)
            print ("Finished in", ms() - startTime, "ms.")
            test_cases.close()

        elif (len(word) == 1) or (word in knownWords):
            print(word)
        
        else:        
            startTime = ms()
            result = spelling_check(word, testing)
            if result is not None:
                # print ("Finished in", ms() - startTime, "ms.")
                print(result)


if __name__ == '__main__':
    main()
